// Scala Un-Grammar.
//
// This grammar specifies the structure of Scala's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node


// TODO: Need to lex all of this
LitExpr = ('-')? 'int_lit'
        | ('-')? 'float_lit'
        | 'true' | 'false'
        | 'character_lit'
        | 'string_lit'
        | 'interpolated_string'
        | 'symbol_lit'
        | 'null'

id = 'ident'
semi = 'semi'
nl = 'nl'

varid = id
boundvarid = id

QualId = id ('.' id)*
ids = id (',' id)*

Path = StableId | (id '.')? 'this'
StableId = id
         | Path '.' id
         | (id '.')? 'super' (ClassQualifier)? '.' id
ClassQualifier = '[' id ']'

Type              = FunctionArgTypes '=>' Type | InfixType (ExistentialClause)?
FunctionArgTypes  = InfixType | '(' ( ParamType (',' ParamType)* )? ')'
// No idea what 'forSome' is, going to comment out for now.
// ExistentialClause = 'forSome' '{' ExistentialDec (semi ExistentialDec)? '}'
ExistentialClause = 'for' '{' ExistentialDec (semi ExistentialDec)? '}'
ExistentialDec    = 'type' TypeDec | 'val' ValDec
InfixType         = CompoundType (id (nl)? CompoundType)*
CompoundType      = AnnotType ('with' AnnotType)* (Refinement)? | Refinement
AnnotType         = SimpleType (Annotation)*
SimpleType        = SimpleType TypeArgs
                  | SimpleType '#' id
                  | StableId
                  | Path '.' 'type'
                  | '(' Types ')'

TypeArgs   = '[' Types ']'
Types      = Type (',' Type)*
Refinement = (nl)? '{' RefineStat (semi RefineStat)* '}'
RefineStat = Dec | TypeDef
TypePat    = Type

Ascription = AscriptionType | AscriptionAnnotation | AscriptionSpread

AscriptionType       = ':' InfixType
AscriptionAnnotation = ':' Annotation (Annotation)*
AscriptionSpread     = ':' '_' '*'

Expr = IfExpr
     | WhileExpr
     | TryExpr
     | DoWhileExpr
     | ForExpr
     | ThrowExpr
     | ReturnExpr
     | LambdaExpr
     | AssignDotExpr
     | PostfixExpr
     | InfixExpr
     | PrefixExpr
     | PostfixExprAscription
     | MatchExpr
     | NewClassExpr
     | NewTemplateExpr
     | BlockExpr
     | PostfixUnderscoreExpr
     | LitExpr
     | Path
     | UnderscoreExpr
     | TupleExpr
     | FieldExpr
     | CallExpr

IfExpr      = 'if' '(' Expr ')' (nl)* Expr ((semi)? 'else' Expr)?
WhileExpr   = 'while' '(' Expr ')' (nl)* Expr
TryExpr     = 'try' Expr ('catch' Expr)? ('finally' Expr)?
DoWhileExpr = 'do' Expr (semi)? 'while' '(' Expr ')'
ForExpr     = 'for' ('(' Enumerators ')' | '{' Enumerators '}') (nl)* ('yield')? Expr
ThrowExpr   = 'throw' Expr
ReturnExpr  = 'return' Expr?

LambdaExpr = (Bindings | ('implicit')? (id | '_')) '=>' Expr

AssignDotExpr = SimpleExpr '=' Expr

PostfixExprAscription = PostfixExpr Ascription
MatchExpr             = PostfixExpr 'match' '{' CaseClauses '}'

PostfixExpr    = Expr id
InfixExpr      = lhs:Expr id rhs:Expr
PrefixExpr     = id Expr // id can only be '-' | '+' | '~' | '!'

SimpleExpr = NewClassExpr
           | NewTemplateExpr
           | BlockExpr
           | PostfixUnderscoreExpr
           | LitExpr
           | Path
           | UnderscoreExpr
           | TupleExpr
           | FieldExpr
           | CallExpr

NewClassExpr    = 'new' ClassTemplate
NewTemplateExpr = 'new' TemplateBody
PostfixUnderscoreExpr = Expr '_'

UnderscoreExpr = '_'
TupleExpr      = '(' (Expr (',' Expr)*)? ')'
FieldExpr      = Expr '.' id
TypedExpr      = Expr TypeArgs
CallExpr       = Expr ArgumentExprList

ArgumentExprList = ParenArguments | SpreadArguments | BlockArguments
ParenArguments  = '(' (Expr (',' Expr)*)? ')'
SpreadArguments = '(' (Expr (',' Expr)*)? PostfixExpr ':' '_' '*' ')'
BlockArguments  = nl? BlockExpr

BlockExpr      = '{' CaseClauses '}' | '{' Block '}'
Block          = BlockStat (semi BlockStat)* (ResultExpr)?
BlockStat      = Import
               | (Annotation)* ('implicit')? ('lazy')? Def
               | (Annotation)* (LocalModifier)* TmplDef
               | Expr
ResultExpr     = Expr
               | (Bindings | ('implicit')? (id | '_') (':' CompoundType)?) '=>' Block

Enumerators    = Generator (semi Generator)*
Generator      = ('case')? PatternSingle '<-' Expr ((semi)? Guard | semi PatternSingle '=' Expr)*

CaseClauses    = CaseClause ( CaseClause )*
CaseClause     = 'case' Pattern (Guard)? '=>' Block
Guard          = 'if' PostfixExpr

// this is Pattern
Pattern        = PatternSingle ( '|' PatternSingle )*
// this is Pattern1
PatternSingle  = boundvarid ':' TypePat
               | '_' ':' TypePat
               | PatternAt
// this is Pattern2
PatternAt      = id ('@' PatternNamed)?
               | PatternNamed
// this is PatternNamed
PatternNamed   = SimplePattern
               | SimplePattern ( id (nl)? SimplePattern )*
SimplePattern  = '_'
               | varid
               | LitExpr
               | StableId
               | StableId '(' (Patterns)? ')'
               | StableId '(' (Patterns ',')? (id '@')? '_' '*' ')'
               | '(' (Patterns)? ')'
Patterns       = Pattern (',' Patterns)?
               | '_' '*'

TypeParamClause    = '[' VariantTypeParam (',' VariantTypeParam)* ']'
FunTypeParamClause = '[' TypeParam (',' TypeParam)* ']'
VariantTypeParam   = (Annotation)* ('+' | '-')? TypeParam
TypeParam          = (id | '_') (TypeParamClause)? ('>:' Type)? ('<:' Type)?
                     ('<%' Type)* (':' Type)*
FunParams         = ParamClause* ((nl)? '(' 'implicit' FunParam (',' FunParam)* ')')?
ParamClause       = nl? '(' (FunParam (',' FunParam)*)? ')'
FunParam          = Annotation* id (':' ParamType)? ('=' Expr)?
ParamType         = Type
                  | '=>' Type
                  | Type '*'

ClassFunParams = (ClassParamClause)* ((nl)? '(' 'implicit' ClassParams ')')?
ClassParamClause  = (nl)? '(' (ClassParams)? ')'
ClassParams       = ClassParam (',' ClassParam)*
ClassParam        = (Annotation)* (Modifier)* ('val' | 'var')?
                      id ':' ParamType ('=' Expr)?
Bindings          = '(' Binding (',' Binding)* ')'
Binding           = (id | '_') (':' Type)?

Modifier      = LocalModifier
              | AccessModifier
              | 'override'
LocalModifier = 'abstract'
                    |  'final'
                    |  'sealed'
                    |  'implicit'
                    |  'lazy'
AccessModifier    =  ('private' | 'protected') (AccessQualifier)?
AccessQualifier   =  '[' (id | 'this') ']'

Annotation        =  '@' SimpleType ArgumentExprList*
ConstrAnnotation  =  '@' SimpleType ArgumentExprList

TemplateBody      =  (nl)? '{' (SelfType)? TemplateStat (semi TemplateStat)* '}'
TemplateStat      =  Import
                  | (Annotation (nl)?)* (Modifier)* Def
                  | (Annotation (nl)?)* (Modifier)* Dec
                  | Expr
SelfType          = id (':' Type)? '=>'
                  | 'this' ':' Type '=>'

Import            = 'import' ImportExpr (',' ImportExpr)*
ImportExpr        = StableId '.' (id | '_' | ImportSelectors)
ImportSelectors   = '{' (ImportSelector ',')* (ImportSelector | '_') '}'
ImportSelector    = id ('=>' id | '=>' '_')?

Dec               = 'val' ValDec
                  | 'var' VarDec
                  | FunDec
                  | 'type' (nl)* TypeDec

ValDec            = ids ':' Type
VarDec            = ids ':' Type
FunDec            = 'def' FunSig '=' Expr
FunSig            = id FunTypeParamClause? FunParams (':' Type)?
TypeDec           = id (TypeParamClause)? ('>:' Type)? ('<:' Type)?

// Definitions

Def = ValPatDef
  | VarPatDef
  | FunEqDef
  | FunBlockDef
  | FunThisDef
  | TypeDef
  | ClassDef
  | ObjectDef
  | TraitDef

PatVarDef = ValPatDef | VarPatDef

ValPatDef = 'val' (PatDef | VarDef)
VarPatDef = 'var' VarDef

PatDef      = PatternAt (',' PatternAt)* (':' Type)? '=' Expr
VarDef      = ids ':' Type '=' '_'
FunEqDef    = FunSig (':' Type)? '=' Expr
FunBlockDef = FunSig (nl)? '{' Block '}'
FunThisDef  = 'this' FunParams ('=' ConstrExpr | (nl)? ConstrBlock)

TypeDef     = 'type' id TypeParamClause? '=' Type

TmplDef          = ClassDef | TraitDef | ObjectDef
ClassDef         = 'case'? 'class' id TypeParamClause? (ConstrAnnotation)* (AccessModifier)? ClassFunParams ClassTemplateOpt
TraitDef         = 'trait' id TypeParamClause? TraitTemplateOpt
ObjectDef        = 'case'? 'object' id ClassTemplateOpt
ClassTemplateOpt = 'extends' ClassTemplate | ('extends'? TemplateBody)?
TraitTemplateOpt = 'extends' TraitTemplate | ('extends'? TemplateBody)?
ClassTemplate    = EarlyDefs? ClassParents TemplateBody?
TraitTemplate    = EarlyDefs? TraitParents TemplateBody?
ClassParents     = Constr ('with' AnnotType)*
TraitParents     = AnnotType ('with' AnnotType)*
Constr           = AnnotType ArgumentExprList*
EarlyDefs        = '{' (EarlyDef (semi EarlyDef)*)? '}' 'with'
EarlyDef         = (Annotation (nl)?)* (Modifier)* PatVarDef

ConstrExpr     = SelfInvocation | ConstrBlock
ConstrBlock    = '{' SelfInvocation (semi BlockStat)* '}'
SelfInvocation = 'this' ArgumentExprList (ArgumentExprList)*

// TopStatSeq     = TopStat (semi TopStat)*
// TopStat        = (Annotation (nl)?)* (Modifier)* TmplDef
//                | Import
//                | Packaging
//                | PackageObject
// Packaging      =  'package' QualId (nl)? '{' TopStatSeq '}'
// PackageObject  =  'package' 'object' ObjectDef
//
// SourceFile = ('package' QualId semi)* TopStatSeq

SourceFile = FunDec*
